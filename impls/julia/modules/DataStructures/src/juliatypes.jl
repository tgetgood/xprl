# Extensions of methods to jl native types

# Ranges are immutable, so let's just use our vectors.
empty(x::AbstractRange) = emptyvector
empty(x::Base.Vector) = []

count(v::Base.Vector) = length(v)
count(xs::Tuple) = length(xs)

"""
Creates a *new* vector containing all elements of `v` appended with `x`.

N.B.: This can be VERY slow for large aggregations, ram usage growing
quadratically with N (plus big constants). I'm not going to waste time
optimising something that shouldn't be used.

If you need immutability, use persistent vectors. If you need speed, use
`into!`. This is only here for completeness and to prevent unexpected failures
in performance agnostic code. But maybe it shouldn't be here at all...
"""
function conj(v::Base.Vector, x)
  if v == []
    # Use x's type instead of `Any` if possible.
    [x]
  else
    @warn "Using full copy-on-write instead of persistent datastructures!"
    vcat(v, [x])
  end
end

rest(v::Base.Array) = v[2:end]
rest(v::UnitRange) = rest(Base.Vector(v))
rest(v::Tuple) = v[2:end]

conj(m::Map, v::Base.Vector) = assoc(m, v[1], v[2])
conj(m::Map, e::NTuple{2, Any}) = assoc(m, e[1], e[2])

function get(v::Base.Vector, i)
  if isdefined(v, Int(i))
    v[i]
  else
    nothing
  end
end

ireduce(f, init, coll::AbstractRange) = Base.reduce(f, coll; init)
ireduce(f, init, coll::Array) = Base.reduce(f, coll; init)
ireduce(f, init, coll::Tuple) = Base.reduce(f, coll; init)

Base.convert(::Type{Vector}, xs::Tuple) = vec(xs)
Base.convert(::Type{Vector}, xs::Base.Vector) = vec(xs)
Base.convert(::Type{Vector}, xs::UnitRange) = vec(xs)

struct InitOnly end

"""
Sets the accumulator arg to a Base.Vector whose eltype is the type of the first
element generated by the xform chain to which this is appended. If the ensuing
values are not all of the same type, replaces the accumulator again with a
Base.Vector{Any} and boxes everything.
"""
function typeset()
  function(emit)
    function inner()
      emit()
    end
    function inner(x::InitOnly)
      []
    end
    function inner(x)
      emit(x)
    end
    function inner(r::InitOnly, n)
        emit(Base.Vector{typeof(n)}(), n)
    end
    function inner(r::Base.Vector{T}, n::T) where T
        emit(r, n)
    end
    function inner(r, n)
      # TODO: reflection warning switch.
      # @warn "Heterogeneous types, boxing."
      emit(Base.Vector{Any}(r), n)
    end
  end
end

"""
Mutates `to` by `push!`ing each element emitted by the application of `xform` to
`from`.

Intended for use with a new empty Base.Vector each time, but that can be
manipulated.

if `infertype` is `true` (default), then try to infer the eltype of the output
collection and avoid boxing. If you know that the type of the first element
produced will be unrepresentative or that `Any` is the correct eltype for the
output collection, then set `infertype` to `false` to avoid the useless
overhead.
"""
function into!(to::Base.Vector, xform, from, infertype=true)
  if isempty(to) && eltype(to) == Any && infertype
    # Try to infer the output type of xform so that we don't box unnecessarily
    # Note that this brings overhead even in the case where we need to box
    # anyway, but the overhead is small and the cost of boxing bits types is
    # huge.
    transduce(xform âˆ˜ typeset(), push!, InitOnly(), from)
  else
    transduce(xform, push!, to, from)
  end
end

function into!(to::Base.Vector, from; infertype=true)
  if isempty(to) && eltype(to) == Any && infertype
    transduce(typeset(), push!, InitOnly(), from)
  else
    reduce(push!, to, from)
  end
end

function conj(s1::String, s2::String)
  s1 * s2
end

function showrecur(io::IO, depth, x::Base.Vector{T}) where T <: Base.Array
  show(io, "text/plain", x)
end

function showrecur(io::IO, depth, x::Base.Vector)
  if length(x) === 0
    print(io, "[]")
  else
    print(io, string(count(x)) * "-element " * string(typeof(x)) * ": [\n")
    showseq(io, depth, x)
    print(io, "]")
  end
end

function conj(_::Tuple{}, x)
  vector(x)
end
